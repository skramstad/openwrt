From adecf407277bc0e9bcccee1d720278ab1dd80416 Mon Sep 17 00:00:00 2001
From: Kristian Skramstad <kristian+github@83.no>
Date: Mon, 30 Dec 2024 20:19:23 +0100
Subject: [PATCH] amd-xgbe: add support for sfp BASE-BX10.

amd-xgbe is missing support for SFP Modules with tranceiver type, Ethernet: BASE-BX10,
or other sfp modules with fibre. With this patch it will recognize BX10
and sfp modules based on wavelength if BX10 is not defined.
Autoneg is enabled by default because some ISP requires this to receive an IP with DHCP.
Tested on FS, Ubiquiti and Pro Optix sfp modules, BiDi 1310/1550 SC/LC.
Note: Added back min/max for sfp_speed or it would not be able to detect
the correct speed.
---
 drivers/net/ethernet/amd/xgbe/xgbe-phy-v2.c | 149 ++++++++++++++++++--
 1 file changed, 136 insertions(+), 13 deletions(-)

--- a/drivers/net/ethernet/amd/xgbe/xgbe-phy-v2.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-phy-v2.c
@@ -133,6 +133,7 @@
 #define XGBE_MUTEX_RELEASE		0x80000000
 
 #define XGBE_SFP_DIRECT			7
+#define GPIO_MASK_WIDTH			4
 
 /* I2C target addresses */
 #define XGBE_SFP_SERIAL_ID_ADDRESS	0x50
@@ -195,10 +196,17 @@ enum xgbe_sfp_cable {
 
 enum xgbe_sfp_base {
 	XGBE_SFP_BASE_UNKNOWN = 0,
+	XGBE_SFP_BASE_PX,
+	XGBE_SFP_BASE_BX10,
+	XGBE_SFP_BASE_100_FX,
+	XGBE_SFP_BASE_100_LX10,
+	XGBE_SFP_BASE_100_BX,
 	XGBE_SFP_BASE_1000_T,
 	XGBE_SFP_BASE_1000_SX,
 	XGBE_SFP_BASE_1000_LX,
 	XGBE_SFP_BASE_1000_CX,
+	XGBE_SFP_BASE_1000_BX,
+	XGBE_SFP_BASE_1000_BX10,
 	XGBE_SFP_BASE_10000_SR,
 	XGBE_SFP_BASE_10000_LR,
 	XGBE_SFP_BASE_10000_LRM,
@@ -208,9 +216,11 @@ enum xgbe_sfp_base {
 
 enum xgbe_sfp_speed {
 	XGBE_SFP_SPEED_UNKNOWN = 0,
+	XGBE_SFP_SPEED_100,
 	XGBE_SFP_SPEED_100_1000,
 	XGBE_SFP_SPEED_1000,
 	XGBE_SFP_SPEED_10000,
+	XGBE_SFP_SPEED_25000,
 };
 
 /* SFP Serial ID Base ID values relative to an offset of 0 */
@@ -220,6 +230,9 @@ enum xgbe_sfp_speed {
 #define XGBE_SFP_BASE_EXT_ID			1
 #define XGBE_SFP_EXT_ID_SFP			0x04
 
+#define XGBE_SFP_BASE_CV			2
+#define XGBE_SFP_BASE_CV_CP			0x21
+
 #define XGBE_SFP_BASE_10GBE_CC			3
 #define XGBE_SFP_BASE_10GBE_CC_SR		BIT(4)
 #define XGBE_SFP_BASE_10GBE_CC_LR		BIT(5)
@@ -231,14 +244,31 @@ enum xgbe_sfp_speed {
 #define XGBE_SFP_BASE_1GBE_CC_LX		BIT(1)
 #define XGBE_SFP_BASE_1GBE_CC_CX		BIT(2)
 #define XGBE_SFP_BASE_1GBE_CC_T			BIT(3)
+#define XGBE_SFP_BASE_100M_CC_LX10		BIT(4)
+#define XGBE_SFP_BASE_100M_CC_FX		BIT(5)
+#define XGBE_SFP_BASE_CC_BX10			BIT(6)
+#define XGBE_SFP_BASE_CC_PX			BIT(7)
 
 #define XGBE_SFP_BASE_CABLE			8
 #define XGBE_SFP_BASE_CABLE_PASSIVE		BIT(2)
 #define XGBE_SFP_BASE_CABLE_ACTIVE		BIT(3)
 
 #define XGBE_SFP_BASE_BR			12
+#define XGBE_SFP_BASE_BR_100M_MIN		0x1
+#define XGBE_SFP_BASE_BR_100M_MAX		0x2
 #define XGBE_SFP_BASE_BR_1GBE_MIN		0x0a
+#define XGBE_SFP_BASE_BR_1GBE_MAX		0x0d
 #define XGBE_SFP_BASE_BR_10GBE_MIN		0x64
+#define XGBE_SFP_BASE_BR_10GBE_MAX		0x68
+#define XGBE_SFP_BASE_BR_25GBE			0xFF
+
+/* Single mode, length of fiber in units of km */
+#define XGBE_SFP_BASE_SM_LEN_KM			14
+#define XGBE_SFP_BASE_SM_LEN_KM_MIN		0x0A
+
+/* Single mode, length of fiber in units of 100m */
+#define XGBE_SFP_BASE_SM_LEN_100M		15
+#define XGBE_SFP_BASE_SM_LEN_100M_MIN		0x64
 
 #define XGBE_SFP_BASE_CU_CABLE_LEN		18
 
@@ -249,6 +279,16 @@ enum xgbe_sfp_speed {
 #define XGBE_SFP_BASE_VENDOR_REV		56
 #define XGBE_SFP_BASE_VENDOR_REV_LEN		4
 
+/*
+ * Optical specification compliance - denotes wavelength
+ * for optical tranceivers
+ */
+#define XGBE_SFP_BASE_OSC			60
+#define XGBE_SFP_BASE_OSC_LEN			2
+#define XGBE_SFP_BASE_OSC_1310			0x051E
+#define XGBE_SFP_BASE_OSC_1439			0x05D2
+#define XGBE_SFP_BASE_OSC_1550			0x060E
+
 #define XGBE_SFP_BASE_CC			63
 
 /* SFP Serial ID Extended ID values relative to an offset of 64 */
@@ -382,6 +422,8 @@ struct xgbe_phy_data {
 	/* KR AN support */
 	unsigned int phy_cdr_notrack;
 	unsigned int phy_cdr_delay;
+
+	u8 port_sfp_inputs;
 };
 
 /* I2C, MDIO and GPIO lines are muxed, so only one device at a time */
@@ -812,10 +854,21 @@ static void xgbe_phy_sfp_phy_settings(st
 	}
 
 	switch (phy_data->sfp_base) {
+	case XGBE_SFP_BASE_100_FX:
+	case XGBE_SFP_BASE_100_LX10:
+	case XGBE_SFP_BASE_100_BX:
+		pdata->phy.speed = SPEED_100;
+		pdata->phy.duplex = DUPLEX_FULL;
+		pdata->phy.autoneg = AUTONEG_DISABLE;
+		pdata->phy.pause_autoneg = AUTONEG_DISABLE;
+		break;
 	case XGBE_SFP_BASE_1000_T:
 	case XGBE_SFP_BASE_1000_SX:
 	case XGBE_SFP_BASE_1000_LX:
 	case XGBE_SFP_BASE_1000_CX:
+	case XGBE_SFP_BASE_BX10:
+	case XGBE_SFP_BASE_1000_BX:
+	case XGBE_SFP_BASE_1000_BX10:
 		pdata->phy.speed = SPEED_UNKNOWN;
 		pdata->phy.duplex = DUPLEX_UNKNOWN;
 		pdata->phy.autoneg = AUTONEG_ENABLE;
@@ -835,6 +888,13 @@ static void xgbe_phy_sfp_phy_settings(st
 				XGBE_SET_SUP(lks, 1000baseX_Full);
 		}
 		break;
+	case XGBE_SFP_BASE_PX:
+		pdata->phy.speed = SPEED_1000;
+		pdata->phy.duplex = DUPLEX_FULL;
+		pdata->phy.autoneg = AUTONEG_DISABLE;
+		pdata->phy.pause_autoneg = AUTONEG_DISABLE;
+		XGBE_SET_SUP(lks, 1000baseX_Full);
+		break;
 	case XGBE_SFP_BASE_10000_SR:
 	case XGBE_SFP_BASE_10000_LR:
 	case XGBE_SFP_BASE_10000_LRM:
@@ -891,22 +951,33 @@ static void xgbe_phy_sfp_phy_settings(st
 static bool xgbe_phy_sfp_bit_rate(struct xgbe_sfp_eeprom *sfp_eeprom,
 				  enum xgbe_sfp_speed sfp_speed)
 {
-	u8 *sfp_base, min;
+	u8 *sfp_base, min, max;
 
 	sfp_base = sfp_eeprom->base;
 
 	switch (sfp_speed) {
+	case XGBE_SFP_SPEED_100:
+		min = XGBE_SFP_BASE_BR_100M_MIN;
+		max = XGBE_SFP_BASE_BR_100M_MAX;
+		break;
 	case XGBE_SFP_SPEED_1000:
 		min = XGBE_SFP_BASE_BR_1GBE_MIN;
+		max = XGBE_SFP_BASE_BR_1GBE_MAX;
 		break;
 	case XGBE_SFP_SPEED_10000:
 		min = XGBE_SFP_BASE_BR_10GBE_MIN;
+		max = XGBE_SFP_BASE_BR_10GBE_MAX;
+		break;
+	case XGBE_SFP_SPEED_25000:
+		min = XGBE_SFP_BASE_BR_25GBE;
+		max = XGBE_SFP_BASE_BR_25GBE;
 		break;
 	default:
 		return false;
 	}
 
-	return sfp_base[XGBE_SFP_BASE_BR] >= min;
+	return (sfp_base[XGBE_SFP_BASE_BR] >= min) &&
+		(sfp_base[XGBE_SFP_BASE_BR] <= max);
 }
 
 static void xgbe_phy_free_phy_device(struct xgbe_prv_data *pdata)
@@ -1207,19 +1278,26 @@ static void xgbe_phy_sfp_parse_eeprom(st
 	phy_data->sfp_tx_fault = xgbe_phy_check_sfp_tx_fault(phy_data);
 	phy_data->sfp_rx_los = xgbe_phy_check_sfp_rx_los(phy_data);
 
-	/* Assume FIBER cable unless told otherwise */
+	/* Assume ACTIVE cable unless told it is PASSIVE */
 	if (sfp_base[XGBE_SFP_BASE_CABLE] & XGBE_SFP_BASE_CABLE_PASSIVE) {
 		phy_data->sfp_cable = XGBE_SFP_CABLE_PASSIVE;
 		phy_data->sfp_cable_len = sfp_base[XGBE_SFP_BASE_CU_CABLE_LEN];
-	} else if (sfp_base[XGBE_SFP_BASE_CABLE] & XGBE_SFP_BASE_CABLE_ACTIVE) {
+	} else
 		phy_data->sfp_cable = XGBE_SFP_CABLE_ACTIVE;
-	} else {
-		phy_data->sfp_cable = XGBE_SFP_CABLE_FIBER;
-	}
 
-	/* Determine the type of SFP */
-	if (phy_data->sfp_cable != XGBE_SFP_CABLE_FIBER &&
-	    xgbe_phy_sfp_bit_rate(sfp_eeprom, XGBE_SFP_SPEED_10000))
+	int wavelen = (sfp_base[XGBE_SFP_BASE_OSC] << 8) | sfp_base[XGBE_SFP_BASE_OSC + 1];
+
+	/*
+	 * Determine the type of SFP. Certain 10G SFP+ modules read as
+	 * 1000BASE-CX. To prevent 10G DAC cables to be recognized as
+	 * 1G, we first check if it is a DAC and the bitrate is 10G.
+	 * If it's greater than 10G, we assume the DAC is capable
+	 * of multiple bitrates, set the MAC to 10G and hope for the best.
+	 */
+	if (((sfp_base[XGBE_SFP_BASE_CV] & XGBE_SFP_BASE_CV_CP) ||
+		(phy_data->sfp_cable == XGBE_SFP_CABLE_PASSIVE)) &&
+	    (xgbe_phy_sfp_bit_rate(sfp_eeprom, XGBE_SFP_SPEED_10000) ||
+		xgbe_phy_sfp_bit_rate(sfp_eeprom, XGBE_SFP_SPEED_25000)))
 		phy_data->sfp_base = XGBE_SFP_BASE_10000_CR;
 	else if (sfp_base[XGBE_SFP_BASE_10GBE_CC] & XGBE_SFP_BASE_10GBE_CC_SR)
 		phy_data->sfp_base = XGBE_SFP_BASE_10000_SR;
@@ -1237,14 +1315,48 @@ static void xgbe_phy_sfp_parse_eeprom(st
 		phy_data->sfp_base = XGBE_SFP_BASE_1000_CX;
 	else if (sfp_base[XGBE_SFP_BASE_1GBE_CC] & XGBE_SFP_BASE_1GBE_CC_T)
 		phy_data->sfp_base = XGBE_SFP_BASE_1000_T;
+	else if (sfp_base[XGBE_SFP_BASE_1GBE_CC] & XGBE_SFP_BASE_100M_CC_LX10)
+		phy_data->sfp_base = XGBE_SFP_BASE_100_LX10;
+	else if (sfp_base[XGBE_SFP_BASE_1GBE_CC] & XGBE_SFP_BASE_100M_CC_FX)
+		phy_data->sfp_base = XGBE_SFP_BASE_100_FX;
+	else if (sfp_base[XGBE_SFP_BASE_1GBE_CC] & XGBE_SFP_BASE_CC_BX10) {
+		/* BX10 can be either 100 or 1000 */
+		if (xgbe_phy_sfp_bit_rate(sfp_eeprom, XGBE_SFP_SPEED_100)) {
+			phy_data->sfp_base = XGBE_SFP_BASE_100_BX;
+		} else {
+			/* default to 1000 */
+			phy_data->sfp_base = XGBE_SFP_BASE_1000_BX;
+		}
+	}
+	else if (sfp_base[XGBE_SFP_BASE_1GBE_CC] & XGBE_SFP_BASE_CC_PX)
+		phy_data->sfp_base = XGBE_SFP_BASE_PX;
+	else if (xgbe_phy_sfp_bit_rate(sfp_eeprom, XGBE_SFP_SPEED_1000)
+			&& (sfp_base[XGBE_SFP_BASE_SM_LEN_KM] >= XGBE_SFP_BASE_SM_LEN_KM_MIN
+			|| sfp_base[XGBE_SFP_BASE_SM_LEN_100M] >= XGBE_SFP_BASE_SM_LEN_100M_MIN)
+			&& wavelen >= XGBE_SFP_BASE_OSC_1310)
+		phy_data->sfp_base = XGBE_SFP_BASE_1000_BX;
+	else if (xgbe_phy_sfp_bit_rate(sfp_eeprom, XGBE_SFP_SPEED_100)
+			&& (sfp_base[XGBE_SFP_BASE_SM_LEN_KM] >= XGBE_SFP_BASE_SM_LEN_KM_MIN
+			|| sfp_base[XGBE_SFP_BASE_SM_LEN_100M] >= XGBE_SFP_BASE_SM_LEN_100M_MIN)
+			&& wavelen >= XGBE_SFP_BASE_OSC_1310)
+		phy_data->sfp_base = XGBE_SFP_BASE_100_BX;
 
 	switch (phy_data->sfp_base) {
+	case XGBE_SFP_BASE_100_FX:
+	case XGBE_SFP_BASE_100_LX10:
+	case XGBE_SFP_BASE_100_BX:
+		phy_data->sfp_speed = XGBE_SFP_SPEED_100;
+		break;
 	case XGBE_SFP_BASE_1000_T:
 		phy_data->sfp_speed = XGBE_SFP_SPEED_100_1000;
 		break;
+	case XGBE_SFP_BASE_PX:
+	case XGBE_SFP_BASE_BX10:
 	case XGBE_SFP_BASE_1000_SX:
 	case XGBE_SFP_BASE_1000_LX:
 	case XGBE_SFP_BASE_1000_CX:
+	case XGBE_SFP_BASE_1000_BX:
+	case XGBE_SFP_BASE_1000_BX10:
 		phy_data->sfp_speed = XGBE_SFP_SPEED_1000;
 		break;
 	case XGBE_SFP_BASE_10000_SR:
@@ -1366,6 +1478,7 @@ static void xgbe_phy_sfp_signals(struct
 	struct xgbe_phy_data *phy_data = pdata->phy_data;
 	u8 gpio_reg, gpio_ports[2];
 	int ret;
+	int shift = GPIO_MASK_WIDTH * (3 - phy_data->port_id);
 
 	/* Read the input port registers */
 	gpio_reg = 0;
@@ -1379,6 +1492,7 @@ static void xgbe_phy_sfp_signals(struct
 	}
 
 	phy_data->sfp_gpio_inputs = (gpio_ports[1] << 8) | gpio_ports[0];
+	phy_data->port_sfp_inputs = (phy_data->sfp_gpio_inputs >> shift) & 0x0F;
 
 	phy_data->sfp_mod_absent = xgbe_phy_check_sfp_mod_absent(phy_data);
 }
@@ -1630,17 +1744,17 @@ static enum xgbe_mode xgbe_phy_an37_sgmi
 		}
 		break;
 	case XGBE_SGMII_AN_LINK_SPEED_1000:
+	default:
+		/* Default to 1000 */
 		if (pdata->an_status & XGBE_SGMII_AN_LINK_DUPLEX) {
 			XGBE_SET_LP_ADV(lks, 1000baseT_Full);
 			mode = XGBE_MODE_SGMII_1000;
 		} else {
 			/* Half-duplex not supported */
 			XGBE_SET_LP_ADV(lks, 1000baseT_Half);
-			mode = XGBE_MODE_UNKNOWN;
+			mode = XGBE_MODE_SGMII_1000;
 		}
 		break;
-	default:
-		mode = XGBE_MODE_UNKNOWN;
 	}
 
 	return mode;
@@ -1746,6 +1860,9 @@ static enum xgbe_mode xgbe_phy_an73_redr
 			case XGBE_SFP_BASE_1000_SX:
 			case XGBE_SFP_BASE_1000_LX:
 			case XGBE_SFP_BASE_1000_CX:
+			case XGBE_SFP_BASE_BX10:
+			case XGBE_SFP_BASE_1000_BX:
+			case XGBE_SFP_BASE_1000_BX10:
 			default:
 				mode = XGBE_MODE_X;
 				break;
@@ -1901,6 +2018,9 @@ static void xgbe_phy_an_advertising(stru
 		case XGBE_SFP_BASE_1000_SX:
 		case XGBE_SFP_BASE_1000_LX:
 		case XGBE_SFP_BASE_1000_CX:
+		case XGBE_SFP_BASE_BX10:
+		case XGBE_SFP_BASE_1000_BX:
+		case XGBE_SFP_BASE_1000_BX10:
 			XGBE_SET_ADV(dlks, 1000baseKX_Full);
 			break;
 		default:
@@ -1950,6 +2070,9 @@ static enum xgbe_an_mode xgbe_phy_an_sfp
 	case XGBE_SFP_BASE_1000_SX:
 	case XGBE_SFP_BASE_1000_LX:
 	case XGBE_SFP_BASE_1000_CX:
+	case XGBE_SFP_BASE_BX10:
+	case XGBE_SFP_BASE_1000_BX:
+	case XGBE_SFP_BASE_1000_BX10:
 		return XGBE_AN_MODE_CL37;
 	default:
 		return XGBE_AN_MODE_NONE;
